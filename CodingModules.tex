\startcomponent[CodingModules]
\starttext

\subsubsubsection[understanding-the-structure-of-xml-documents]{Understanding The Structure of XML Documents}

Below is a very unusual description of a man named Richard. It's not code (it won't do anything if you plug it into FAIMS-Tools, because it contains no recognizable instructions), but it's written in a format very similar to what your module's code will look like. Take a minute and look it over and try to guess, just from the text and the way it's formatted, what Richard looks like.

<Richard>

  </Old>

  <Hair>

    <Grey/>

    <Wavy/>

  </Hair>

  <Shirt>

    <Black/>

    <Sleeveless/>

    <Printed>

      <Midnight Oil Diesel and Dust Tour/>

      <Faded/>

    </Printed>

  </Shirt>
  <Watch>
    <Gold/>
  </Watch>
</Richard>

If you can read this and understand that Richard is old, that he's got wavy grey hair, that he's wearing a black Midnight Oil Dust and Diesel shirt with faded print, and that he has a gold watch, congratulations: you have already grasped the basic principle of how code in XML documents is structured. If not, try again with that information in mind.

Do you see how the description has a kind of flow to it? How the big category "Richard" is divided into smaller and more specific categories containing individual details? "Grey" and "Wavy" are singular details contained within the category "Hair," which is itself contained within the person "Richard"; therefore Richard has hair that is both grey and wavy. "Faded" and "Midnight Oil Diesel and Dust Tour" are contained within the category "Printed," which is contained along with "Black" and "Sleeveless" within the category "Shirt," which is contained within the person "Richard;" therefore Richard has a shirt, the shirt is black and sleeveless and printed, and the print is faded and says "Midnight Oil Diesel and Dust Tour." Because the details are contained within categories that have a beginning and an end, you know they pertain only to the thing that contains them; we know that Richard's shirt is not wavy, his hair is not black, and he as a person is not Faded. We also know that he's old, because within the person Richard is the detail "Old," but not whether or not his watch is old because the detail "Old" only appears in the person "Richard."

Let's take that basic understanding and look at this section of actual code from the Oral History module's module.xml. You probably won't know what it means or does yet yet, but for now, just focus on the structure as we explain each part of it in detail.

<User f="nodata">

  <User>

    <Select_User t="dropdown" f="user" />

    <Login t="button" l="Control" />

  </User>

</User>

The first thing to understand is the purpose of the angle brackets, <>. By enclosing text that has utility in XML, the angle brackets create something called a {\em tag}. The tag is the basic, functional unit of XML documents. 

Tags contain information, and the information they contain is referred to as an {\em element}*{\em .} In our first example, the tags <Richard> and </Richard> defined the boundaries of the element Richard, and everything between them was contained within that element.

*Remember when we talked about archaeological and relationship elements? Now may be a good time to review.

Usually, elements are defined by two tags: the {\em opening tag}, and the {\em closing tag.} Opening tags signify that a new element is beginning. Creating an opening tag instructs that computer that everything that follows until the closing tag (which will be the same as the opening tag, but begin with a / ) is part of that element. For example, the tag <User> states that everything until the closing tag, </User>, is part of the element {\em User} being outlined{\em . }

You may notice that there's two "</User>" tags above. You can probably guess from the way the code snippet is indented that the very last </User> closing tag corresponds to the very first tag, <User f="nodata"> (we'll explain later why this isn't closed by the tag, </User f="nodata">). However, it's worth mentioning that formatting doesn't really matter to FAIMS-Tools when it interprets how your code works; indenting when you start a new element is just a good practice for helping you keep track of your code. So in instance, and others like it: how does FAIMS-Tools decide which </User> closing tag belongs to which <User> opening tag?

Remember that opening and closing tags are used to show that elements are contained within one another. That's the key word to keep in mind: {\em contained}. It may help to think of opening and closing tags as functioning like parentheses or quotation marks. If we consider the following sentence:

I went to the store (the one that had the food I like (eggs, milk, bacon) and low prices) in my car.

It's clear that the idea (eggs, milk, bacon) needs to be concluded before the idea of (the one that had the food I like and low prices) can be resumed and itself concluded. Therefore, we instinctively know that the first right parentheses belongs to the most recent left parentheses, not to the first one. Beginning and end tags work the same way. You can't close the first "User" element if the second "User" element, more recently begun, hasn't itself been closed. 

You may have noticed that the XML code snippet contains two tags which don't fall into either the "opening tag" or "closing tag" categories:

<Select_User t="dropdown" f="user"/>

<Login t="button" l="Control"/>

These are known as {\em empty-element tags}. Sometimes, an element is complete with only a single instruction. It's not creating something larger that has multiple qualities; it's just a single detail, such as a simple button the user can press. In these cases, it isn't really necessary to have both an opening and a closing tag, as there's nothing to put between them. The above tags are really just shorthand for the following:

<Select_User t="dropdown" f="user">

</Select_User>

<Login t="button" l="Control"/>

</Login>

There's no point in having an opening AND closing tag if there's nothing you're going to put between them. Hence the name, "empty element tags"; they denote elements which do not contain any other elements.

TEST YOUR KNOWLEDGE:

1: What's the connection between "tags" and "elements"?
2: If you've got two of the same opening tag and neither has been closed yet, which will the first closing tag you write belong to?
3: Where do you put the slash (/) to denote an empty element tag?

\subsubsubsection[understanding-the-faims-xml-format]{Understanding The {\em FAIMS} XML Format}

So that's how XML is structured. How does that structure relate to FAIMS modules?

FAIMS modules have the same kind of hierarchical structure as other XML documents: all {\bf GUI elements} (ie, the user interface) such as buttons, text fields, and dropdown menus appear inside of {\bf tabs}.

Consider for a moment the module in the image shown below and to the left. There are {\bf GUI elements} (or, "useful parts you can interact with") which all belong to the "Recording Form" tab. If the user were to tap on a different tab, for instance the "Interview Details" tab, they would see a different set of GUI elements belonging to that different tab. 

The other image (below, right) shows all the {\bf tabs} which belong to a presently displayed {\bf tab group} called "Form". Entering a different tab group would cause a different set of tabs to be displayed. The below image shows two different tab groups---"Control" and "Form"---each containing their own sets of tabs.

{\externalfigure[images/image71.png][width=.5\textwidth]}{\externalfigure[images/image64.png][width=.5\textwidth]}

So the hierarchy flows: your module has tab groups have tabs which have GUI elements. When you structure the elements of module.xml, it'll be contained exactly the same way. Your module element will contain tab group elements will contain tab elements which will contain GUI elements, many of which may be empty elements as they'll stand on their own without needing to contain anything else. Make sense so far? Let's see what it looks like in practice.

{\externalfigure[images/image47.png][width=.5\textwidth]}{}

<?xml version="1.0"?>

<module>

<Tab_Group>

<Tab_1>

<Select_User t="dropdown" f="user"/>

<Login t="button" l="Control"/>

</Tab_1>

<Tab_2>

<Button t="button" />

</Tab_2>

</Tab_Group>

</module>

Remember that you're creating a version of module.xml that XML-Tools can read and interpret in creating your necessary files. Because XML-Tools understands the hierarchical structure we've just explained, it'll automatically understand whether something is a tab group or tab just from where it falls in the hierarchy. XML-Tools knows that <Tab_Group> is a tab group not because of its name, but because it appears straight away from the <module> tags without being contained in anything else. \footnote{There are some caveats to this rule, but it is true in the vast majority of instances.}. Similarly, elements which appear directly within a tab group are automatically understood to be tabs. XML elements within tabs are interpreted as GUI elements.

TEST YOUR KNOWLEDGE: 

Review the following structure.

<module>
      
      <A>
  
            <B>
                  <C/>
                  <C/>
            </B>
    
            <B>
                  <C/>
            </B>
      </A>
  
      <A>
            <B>
                  <C/>
                  <C/>
                  <C/>
            </B>
        </A>


</module>

Without knowing what's really inside the tags, can you figure out which elements are the tab groups, which are the tabs, and which are UI elements? If you have difficulty guessing that the "A" elements are tab groups, the "B" elements are tabs, and the "C" elements are the GUI, you may need to review the previous section. 

Now that you understand the how the XML structure relates to FAIMS modules, let's explore the simple module we uploaded in the last section.

{\externalfigure[images/image25.png][width=.5\textwidth]}{}

To create this first login screen, we used the following XML code:

<User f="nodata">

<User>

<Select_User t="dropdown" f="user"/>

<Login t="button" l="Control"/>

</User>

</User>

The outermost set of <User> tags comes right after the <module> tags, so they create a {\bf tab group}. You can name these whatever you want. The only rule you should follow, for reasons we'll get into very shortly, is that it should start with an uppercase letter. The {\em tag name} you write is displayed in the breadcrumb navigation bar at the top of the screen.

Notice that the topmost <User> tag contains the {\em attribute} "f" with an {\em attribute value} of "nodata". Including the word "nodata" in the "f" attribute's value prevents the FAIMS-Tools from automatically generating unwanted code associated with the data schema. In practical terms: inputs that are provided in the "User" tab group, including the "Select User" dropdown menu, are not considered "data" that must be saved to the FAIMS database. We chose to put "nodata" here because we only want the "User" tab group to be for letting people log in.

Now that we've got our <User> tab group, it's time to make our actual <User> tab with its relevant GUI elements. We're naming this tab "User" as well, because it's where the User logs in and that seems like a good name, but we could have named it something else if we thought we'd get it confused with the tab group. Whatever tag name we choose will be displayed in the list of tabs. When you name a tab group something, its tag name must be capitalized.

The <Select_User> and <Login> elements represent GUI elements, or the actual things users will interact with when they're viewing a tab. Notice the "t" attribute, which is where we can define part of what this element looks like or does. You'll find a list of these in the FAIMS cookbook. For <Select_User> we're using t="dropdown", which means this GUI element is a drop-down menu. 

So how do we determine what's in that drop down menu? In this case, by creating an attribute, f="users", which in this context FAIMS understands to mean "get the list of usernames from the server and put them here."

\footnote{{\bf Note from FAIMS programmer Christian Nassif-Haynes:} If you use t=dropdown, then it is possible for the user to avoid logging in (in error or intentionally) by selecting the null option and clicking the login button. If you want to prevent logging with the null user option (de facto avoiding the login), then you need to manually modify the ui_logic.bsh file after it's been generated or use t=list, following the guidelines below. Lists, unlike dropdowns, do not allow null elements so using a t="list" for login, as in the code below, prevents the problem of logging in with null user.

 <User f="nodata">\crlf
 <User f="noscroll">\crlf
 <Select_User t="list" f="user" l="Control"/>\crlf
 </User>\crlf
 
 Setting t="button", as in the case of <Login>, creates a button you can tap. The purpose of the button is described by the text that comes after it; otherwise, it's just a button, which probably isn't going to be very useful for your module. Here we've included the code l="Control" within the tag, which causes FAIMS to link to the "Control" tab group when it is tapped. In fact, the "l" attribute works not only for buttons, but many other GUI elements as well. Note carefully that the "Control" tab group linked to by the "l" attribute's value is defined further down in the module.xml file; this code only functions because the destination is valid. If we had 1="Control" and then didn't actually have a "Control" to link to, it's safe to say this wouldn't work. Also note that references are case-sensitive, so writing "control" with a lower-case "c" would fail.
 
 So let's say we're using our module, we've just clicked the dropdown menu and chosen our user, then we've hit the button that says "Login." If you're using the finished sample module, you'll find yourself looking at this screen:
 
{\externalfigure[images/image46.png][width=.5\textwidth]}{}

Let's take a look at the code for this tab group here. As you review it, see if you can figure out which elements are tab groups, tabs, and GUI elements.

<Control f="nodata">

<Main>

<Record_Interview t="button" l="Interview"/>

<GPS_Diagnostics t="gpsdiag"/>

</Main>

<search>

Records

</search>

</Control>

{\externalfigure[images/image43.png][width=.5\textwidth]}{}

The XML in module.xml describes the different FAIMS elements and how they should appear in the module.

This "Control" tab group encompasses two other elements, "Main" and "Search." Let's look at each individually.

The <Main> element creates the first tab. Inside that tab we have a GUI element, "Record_Interview." The t="button", which means this element is a button; 1="Interview", so the button links to another tab somewhere else in the module called "Interview."  The other GUI element here is "GPS Diagnostics," which has the element type "gpsdiag." This element type specifically means that in the final module, it will create text labels and display information about the Android device's GPS location. In the screenshot, we see the "gpsdiag" element at work: it's telling us that our phone's GPS is "not initialized," a charming way of saying "not turned on." Until we do turn it on, this is the best "gpsdiag" is going to do.

Let's turn on our Android device's internal GPS antenna by tapping \useURL[url22][https://www.youtube.com/watch?v=o_eSwq1ewsU][][{\em the three vertical dots}]\from[url22] in the upper right of the screen to open the settings menu.

{\externalfigure[images/image45.png][width=.5\textwidth]}{\externalfigure[images/image34.png][width=.5\textwidth]}

With the GPS antenna turned on, the "gpsdiag" element now displays quite a bit more information, including the status of the GPS antenna, location in both Latitude/Longitude and Easting/Northing, and an accuracy measurement.

So much for the <Main> tab. Let's look at the next tab, which you may have already noted is a little peculiar. For one thing, the tag name begins with a lowercase letter. Didn't we tell you never to do that? Furthermore, the text contained within, "Records," isn't in tags. What's going on here?

Don't worry; you haven't missed anything. It's just that there are certain kinds of tabs that FAIMS-Tools is already specially programmed to recognize. These kinds of tabs are complicated and a lot of work to make, so rather than ask you to create them, we've created a shorthand that FAIMS-Tools recognizes and runs with. These "shorthand" tabs have lowercase names, which is why you generally shouldn't come up with a lowercase tag name; you might accidentally write the name of a shorthand FAIMS-Tools recognizes, which will create a mess as it tries to follow its prewritten instructions at the same time as the instructions you've created.

In this case, the tab is "search," which, once some data has been collected, will contain GUI elements that allow you to search records according to various criteria, including term or entity type. We don't have to include code for all these GUI elements; FAIMS-Tools knows to include them in a tab labelled with the shorthand "search". The only thing we have included is the plaintext "Records", without a tag. When FAIMS-Tools sees text like this written inside an element, it labels the element that way instead of basing its name on the tab group. This is why you see "Records" as the tab label when you might have expected to see "search".

{\externalfigure[images/image69.png][width=.5\textwidth]}{\externalfigure[images/image65.png][width=.5\textwidth]}

The Search element before and after adding a few records.

Going back to the finished module, let's tap the "Main" tab and then click the "Record Interview" button, which, you may recall, will take us to "Interview." "Interview" looks like this:

{\externalfigure[images/image44.png][width=.5\textwidth]}{\externalfigure[images/image6.png[width=.5\textwidth}{\externalfigure[images/image22.png][width=.5\textwidth]}

The code to create this long screen looks like this. This is a lot more code than you've seen before in one go, but it serves as a very useful example of a lot of different techniques, so resist the urge to skim it. Take your time, and when you don't recognize what a tag is or what an element is for, see if you can guess what it does just from context. 

<Interview>

<Interview>

<Title f="id notnull">

<desc>This title should be a sensible title, unique to each item, briefly summarising the contents of the item, for example "Ilocano songs recorded in Burgos, Ilocos Sur, Philippines, 17 April 1993"</desc>

</Title>

<Description f="notnull">

<desc>Description may include but is not limited to: an abstract, table of contents, reference to a graphical representation of content, or a free-text summary account of the content. {[}DCMT{]} Description may also offer an annotation, or a qualitative or evaluative comment about the resource, such as a statement about suitability for a particular application or context.</desc>

</Description>

<Private t="radio" f="notnull">

<desc>Choose either "false", meaning that the metadata for the item should be publicly available, or "true", meaning that the metadata for the item should be hidden (perhaps because you plan to check it and edit it later).</desc>

<opts>

<opt>True</opt>

<opt>False</opt>

</opts>

</Private>

<Origination_Date f="notnull">

<desc>Date the item was captured or created, using the format yyyy-mm-dd. If you are unsure of the day, month or decade enter the first day of the relevant period: e.g. "1970s" 1970-01-01, "2001" 2001-01-01, "February 1993" 1993-02-01. If entering a date of this type, clarify in the originationDateNarrative field. If you really did record on 1 January 2001, say so in the originationDate field.</desc>

</Origination_Date>

<Origination_Date_Narrative>

<desc>Use this field to provide any necessary comments on the scope of the value you entered in the origination date field, e.g. "unknown date in February 1993"</desc>

</Origination_Date_Narrative>

<Add_Agent_Role t="button" lc="Agent_Role"/>

<List_of_Agent_Roles t="dropdown" ec="Agent_Role"/>

<Linguistic_Data_Type>

<desc>If data are relevant to linguistics, choose one of the three basic linguistics data types. Primary text: Linguistic material which is itself the object of study; Lexicon: a systematic listing of lexical items; Language description: describes a language or some aspect(s) of a language via a systematic documentation of linguistic structures. If your data are not relevant to linguistics, leave this field blank.</desc>

<opts>

<opt>Lexicon</opt>.

<opt>Language Description</opt>

<opt>Primary Text</opt>

</opts>

</Linguistic_Data_Type>

<Discourse_Type>

<desc>Used to describe the content of a resource as representing discourse of a particular structural type. Dialogue: interactive discourse with two or more participants; drama: planned, creative, rendition of discourse involving two or more participants; formulaic: ritually or conventionally structured discourse; ludic: language whose primary function is to be part of play, or a style of speech that involves a creative manipulation of the structures of the language; oratory: public speaking, or of speaking eloquently according to rules or conventions; narrative: monologic discourse which represents temporally organized events; procedural: explanation or description of a method, process, or situation having ordered steps; report: a factual account of some event or circumstance; singing: words or sounds {[}articulated{]} in succession with musical inflections or modulations of the voice; unintelligible: utterances that are not intended to be interpretable as ordinary language.</desc>

<opts>

<opt>Dialogue</opt>

<opt>Drama</opt>

<opt>Narrative</opt>

<opt>Procedural</opt>

<opt>Ludic</opt>

<opt>Singing</opt>

<opt>Oratory</opt>

<opt>Report</opt>

<opt>Unintelligible speech</opt>

<opt>Formulaic</opt>

</opts>

</Discourse_Type>

<Linguistic_Subject>

<desc>Use to describe the content of a resource if it is about a particular subfield of linguistic science.</desc>

<opts>

<opt>Phonology</opt>

<opt>Text And Corpus Linguistics</opt>

<opt>Historical Linguistics</opt>

<opt>Language Documentation</opt>

<opt>Lexicography</opt>

<opt>Typology</opt>

</opts>

</Linguistic_Subject>

<Country f="notnull">

<desc>This should be the standard name of the country in which the file was recorded (see http://www.ethnologue.com/country_index.asp). Prefix the country name with the two-letter ISO3166-1 code (http://www.iso.org/iso/country_codes.htm).</desc>

<opts>

<opt>PH - Philippines</opt>

<opt>AU - Australia</opt>

</opts>

</Country>

<Region_Villiage>

<desc>Indicate the geographical scope of the item. Enter data in the order locality, state or province, country.</desc>

<opts>

<opt>{[}locality{]}, {[}state or province{]}, {[}country{]}</opt>

<opt>Burgos, Ilocos Sur, Philippines</opt>

</opts>

</Region_Villiage>

<Language_Local_Name>

<desc>The purpose of this field is to reflect language names in local use, with local spellings, if different from official name.</desc>

<opts>

<opt>Language - local spelling {[}free text{]}</opt>

<opt>Ilocano</opt>

</opts>

</Language_Local_Name>

<Language_Content_ISO639-3>

<desc>Content language is the language included in your data (spoken and/or written). Insert the 3-letter ISO 639-3 code for your language, and the standard name of the language as spelt in the ethnologue entry {[}search on www.ethnologue.com/site_search.asp{]}. Separate the code and the language with a hyphen, e.g. "ilo - Ilocano"</desc>

<opts>

<opt>mis - Uncoded languages</opt>

<opt>und - Undetermined languages</opt>

<opt>mul - Multiple languages</opt>

<opt>zxx - No linguistic content</opt>

<opt>{[}3-letter ISO639-3 code{]} - {[}Ethnologue name of language{]}</opt>

<opt>ilo - Ilocano</opt>

<opt>eng - English</opt>

</opts>

</Language_Content_ISO639-3>

<Language_Subject_ISO639-3>

<desc>Subject language is the language that is the subject of your research. Insert the 3-letter ISO 639-3 code for your language, and the standard name of the language as spelt in the ethnologue entry {[}search on www.ethnologue.com/site_search.asp{]}. Separate the code and the language with a hyphen, e.g. "ilo - Ilocano"</desc>

<opts>

<opt>zxx - No linguistic content</opt>

<opt>{[}3-letter ISO639-3 code{]} - {[}Language subject of your research{]}</opt>

<opt>mis - Uncoded languages</opt>

<opt>und - Undetermined languages</opt>

<opt>mul - Multiple languages</opt>

<opt>ilo - Ilocano</opt>

</opts>

</Language_Subject_ISO639-3>

<Attached_Audio t="audio"/>

<Attached_Video t="video"/>

</Interview>

</Interview>

First, the easy stuff. You should already be able to guess what the first element, <Interview>, is: a tab group. Since there's another opening tag also called <Interview>, you've probably also guessed that the tab group <Interview> has a tab labelled <Interview>. So let's skip straight to the GUI elements located within this tab.

The first element is <Title>.

<Title f="id notnull">

<desc>This title should be a sensible title, unique to each item, briefly summarising the contents of the item, for example "Ilocano songs recorded in Burgos, Ilocos Sur, Philippines, 17 April 1993"</desc>

</Title>

For the <Title> element, there is no UI "type" (represented by t=) specified. So it becomes the default "type;" a text input field. (See \goto{{\em Type Guessing for GUI Elements in FAIMS-Tools}}[type-guessing-for-gui-elements-in-faims-tools] for an explanation of how this was determined.) The flag "f=notnull" designates that this is a required field; the record cannot be saved if it is empty. If you can imagine your stress levels skyrocketing because of teammembers not remembering to enter in their (X), set the relevant element to "f=notnull" and they will have no choice but to remember. 

<desc> allows you to set a description that your users can access by tapping and holding for a few seconds on the info button:

{\externalfigure[images/image70.png][width=.5\textwidth]}{}

That wraps up the <Title> element. Now we have an opening tag for another GUI element, <Private>. Private is a radio button UI object, required, has a description, and includes two options ("True" and "False"). Review the code below and see if you can understand how all of this is accomplished.

<Private t="radio" f="notnull">

<desc>Choose either "false", meaning that the metadata for the item should be publicly available, or "true", meaning that the metadata for the item should be hidden (perhaps because you plan to check it and edit it later).</desc>

<opts>

<opt>True</opt>

<opt>False</opt>

</opts>

</Private>

This next element, <Add_Agent_Role>, designates a button element ('t="button"') that links to the tab group "Agent_Role." This will allow users to register new Agent Roles.

<Add_Agent_Role t="button" lc="Agent_Role"/>

Note that this time, instead of using an "l" to redirect elsewhere, "lc" was used. The difference is that using "lc" instead of "l" establishes a parent-child relationship, with the entity linking becoming a parent and the entity being linked to becoming a child. This is useful for organizing your module's data in a neat, hierarchical way. 

The next block designates a dropdown menu, <List_of_Agent_Roles>, which is populated with a list of Agent_Role records. Specifically, they will be the Agent_Role records which were saved using the button element above. The FAIMS-Tools knows these are the right records to display because the button and dropdown menu appear in the same tab group.

<List_of_Agent_Roles t="dropdown" ec="Agent_Role"/>

The final two element types used in this tab are the 't="audio"'' and 't="video"' types. These two element types allow you to record audio and video files and attach them to your records.

<Attached_Audio t="audio"/>

<Attached_Video t="video"/>

{\externalfigure[images/image58.png][width=.5\textwidth]}{}

With the audio UI element, you'll get a popup window that allows you to start and stop your audio recording.

The final elements are on the Agent Role tab group, and include a few element types we've already seen: two text input fields: <First_Name> and <Last_Name> both with flags that designate them as "ids" and a dropdown menu, <Role> which contains a few options and is also flagged as an "id."

{\externalfigure[images/image54.png][width=.5\textwidth]}{}

<Agent_Role>

<desc>Enter participant name in the format Lastname, Firstname. Choose the participant role from the closed vocabulary provided. Use the description field to provide additional information on role or agents. Enter participant name in the format Lastname, Firstname. Choose the participant role from the closed vocabulary provided. Add more participants by clicking the "+" button to the right. If you need to provide extra information on the agent or the role, use the item's "Description" field to provide additional information on role or agents.</desc>

<Agent_Role>

<First_Name f="id"/>

<Last_Name f="id"/>

<Role f="id">

<opts>

<opt>Data Inputter</opt>

<opt>Performer</opt>

<opt>Speaker</opt>

<opt>Developer</opt>

<opt>Transcriber</opt>

<opt>Photographer</opt>

<opt>Interpreter</opt>

<opt>Singer</opt>

<opt>Signer</opt>

<opt>Compiler</opt>

<opt>Recorder</opt>

<opt>Depositor</opt>

<opt>Interviewer</opt>

<opt>Editor</opt>

<opt>Author</opt>

<opt>Translator</opt>

<opt>Researcher</opt>

<opt>Annotator</opt>

<opt>Participant</opt>

</opts>

</Role>

</Agent_Role>

</Agent_Role>

Now that we've explained each part, go back and review the whole one more time. You can go a long way creating modules for your team only by using the techniques we've explicitly covered above. It's very possible that you've already learned everything you need to know to make an effective module for your team.

As an exercise, follow these instructions and produce your own copy of the module's code in module.xml. Then save that to the server and run the generate.sh script to produce necessary files. Go to "create module" and upload the necessary files to the server as the "Simple Sample Module." 

Congratulations; you've just a simple module. 

\subsubsection[section-5]{}



\subsubsection[iterating-to-match-the-oral-history-module]{Iterating to Match the Oral History Module}

Now that we've created a very straightforward version of the Oral History module, let's layer in some additional features. By the end of this section, we will have discussed all the steps that went into making the version of the Oral History Module you can download from the FAIMS Demo Server.

Select "Demo Server" from the dropdown menu in the FAIMS setting menu, then download the "finished" version of the Oral History module. Our goal in this section will be to update the version you produced to match this more complex iteration.

{\externalfigure[images/image48.png][width=.5\textwidth]}{}

The Oral History module has a bit more metadata information included than the version we've already discussed. You can update this information in the "Module" tab on your FAIMS server installation.

{\externalfigure[images/image33.png][width=.5\textwidth]}{\externalfigure[images/image59.png][width=.5\textwidth]}

The first screen of the Oral History Demo looks similar to our module:

{\externalfigure[images/image31.png][width=.5\textwidth]}{}

In the same module.xml file we used for our version of Oral History update the following code:

<User f="nodata">

<User>

<Select_User t="dropdown" f="user"/>

<Login t="button" l="Control"/>

</User>

</User>

to match this (new code in {\bf bold}):

<User f="nodata">

{\bf <User_List>}

{\bf <Users t="list" f="user" l="Control">}

{\bf Users:}

{\bf </Users>}

{\bf </User_List>}

</User>

This replicates the "User List" tab illustrated in the above screenshot. 

Save your modified module.xml, run "{\em ./generate.sh}" in your Ubuntu terminal again, edit your current module and upload the new necessary files in place of the old ones. Now donwload this updated module to your FAIMS app. 

Importantly, to download the updated version of the module, you must touch and hold the "Simple Sample Module" in the list of modules until the below dialogue is displayed:

{\externalfigure[images/image14.png][width=.5\textwidth]}{}

Tap "Update", then "Update Settings", wait for the update to occur, and finally load the module as usual.

{\bf Note: While we can update Simple Sample Module to have an interface that mimics the Oral History module, we're going to make some changes that will make the module not completely functional. This is because, as you may recall, you can't change the Data Schema of a module once it's already been uploaded to the server. So the interface elements will look right, because the necessary files that govern those can be changed out freely, but the parts actually responsible for managing the data you collect to the server won't have gotten the memo that the module's been altered. If this weren't an exercise, and we wanted an absolutely functional module, we'd just create a new one from the updated necessary files and tell our team members to switch to it. 

{\externalfigure[images/image24.png][width=.5\textwidth}{}

On this next screen (shown in the screenshot above), we need to condense a few elements from our original module. Change the following code:

<Control f="nodata">

<Main>

<Record_Interview t="button" l="Interview"/>

<GPS_Diagnostics t="gpsdiag"/>

</Main>

<search>

Records

</search>

</Control>

to match the following:

<Control f="nodata">

{\bf <Control>}

{\bf <New_Oral_History_Form t="button" l="Form"/>}

{\bf <New_Diary t="button" l="Diary"/>}

{\bf <GPS_Diagnostics t="gpsdiag"/>}

{\bf <Sample_Types t="dropdown" />}

{\bf <List_of_Samples t="list" />}

{\bf </Control>}

</Control>

This code replaces the "Main" and "Record" tab groups with a single one labelled "Control". (In a moment, we will define the "Form" and "Diary" tab groups linked to by the above buttons. We will also have to populate the "Sample Types" dropdown and "List of Samples" list by writing some additional code.)

Save module.xml and run the generate.sh script again. Now use them to update your module again. You should see something similar to the image below after selecting a user in the uploaded module.

{\externalfigure[images/image8.png][width=.5\textwidth]}{}

For the next step, we'll add new UI tab groups for each of our buttons: "Form" and "Diary" that we linked to in the last code block:

<Form>

<Recording_Form>

</Recording_Form>

<Interview_Details>

</Interview_Details>

<Main_Subjects>

</Main_Subjects>

</Form>

<Diary>

<Diary>

</Diary>

</Diary>

Make sure that the <Form> and <Diary> elements are written directly within <module> so that the FAIMS-Tools correctly interprets them as tab groups. It may help, when drafting new elements, to write both the opening and closing tags and then fill in the middle.

Now, under each of these new tab groups, we'll create individual tabs. The "Form" group has three tabs: "Recording Form","Interview Details", and "Main Subjects". Note that if these tab titles contain multiple words, you must use underscores between each word. When FAIMS creates the title for each tab, underscores will be replaced with spaces.

{\externalfigure[images/image53.png][width=.5\textwidth]}{}

Now we have the individual tabs for each section, but those tabs don't have any content just yet. For simple text fields, like "Birth Place" and "Parents' Birth Place" you can simply add a self-closing tag with the field's title:

<BIRTH_PLACE />

Also, non-alphabetical characters, like apostrophes are not allowed as tag names in XML, so the FAIMS-Tools would fail to generate a module which contains the following:

<PARENTS'_BIRTH_PLACE:/>

If such characters must be included, the solution is to firstly give the element a sensible name without an apostrophe or colon:

<PARENTS_BIRTH_PLACE/>

Then, to make FAIMS-Tools display the apostrophe and colon in the GUI, write them as the element's text:\crlf
\crlf
<PARENTS_BIRTH_PLACE>

PARENTS' BIRTH PLACE:

</PARENTS_BIRTH_PLACE>

This is similar to what we did with the "search" feature in the last section.

Now, note that every tab group which you intend to save requires at least one {\em identifier}. In the original Oral History module, the identifiers were "PERSON" and "LANGUAGE_GROUP". We can use the "f" attribute to denote that in our new module:

<PERSON f="id"/>\crlf
<LANGUAGE_GROUP f="id"/>

For the GPS fields and their corresponding "Take From GPS" button, enter:

<gps/>

<gps> is a special, self-contained shortcut tag that FAIMS will replace with several fields for the latitude, longitude, Easting, and Northing, as well as a button for inserting this data from GPS.

To add fields for attached files, you can use the "Audio" and "Video" tags, as before:

<Attached_Audio_Files t="audio" />

<Attached_Videos t="video" />

Simply set the type "t" to video or audio as required.

{\externalfigure[images/image26.png][width=.5\textwidth]}{\externalfigure[images/image15.png][width=.5\textwidth]}{\externalfigure[images/image52.png][width=.5\textwidth]}

To add the radio buttons, use the code:

<Recorded t="radio">

Recorded?

<opts>

<opt>Recorded</opt>

<opt>Notes Only</opt>

<opt>No</opt>

</opts>

</Recorded>

Note that to have the radio buttons' contents appear would require that the entire module is re-created and uploaded to the FAIMS server. Updating the existing module on the server, would cause the menu to appear but lack its options.

{\externalfigure[images/image42.png][width=.5\textwidth]}{\externalfigure[images/image49.png][width=.5\textwidth]}

The "Timestamp" and "Created By" values are not actually fields that we'll allow users to enter in manually, so we won't put in a data entry field. Instead, we'll make FAIMS set and update these fields when the record is created. Since there's no simple shortcut for that, for now we'll put in the code:

<Timestamp/>

<Created_by/>

There's actually not a lot more we can do until we've generated our necessary files. Then, we'll take ui_logic.bsh and make a few alterations that make use of these tags.

{\externalfigure[images/image37.png][width=.5\textwidth]}{\externalfigure[images/image1.png][width=.5\textwidth]}

\subsubsection[additional-features]{Additional Features}

In no particular order, here are some other useful things you can do for your module in module.xml.

\subsubsubsection[add-a-picture-gallery]{Add a Picture Gallery}

Remember when we told you how to add a tarball of images to your module? If you use the element type "picture," you can allow user selectable options to be displayed as these images. Take a look at this tab here:

<Script t="picture">

<desc>Type of used script.</desc>

<opts>

<opt p="picture1.jpg">Archaic-Epichoric</opt>

<opt p="picture2.jpg">Old-Attic</opt>

<opt p="picture3.jpg">Ionic</opt>

<opt p="picture4.jpg">Roman</opt>

<opt p="picture5.jpg">Indistinguishable</opt>

<opt p="picture6.jpg">Other</opt>

</opts>

</Script>

Each picture is referenced by the tag, then labeled with the non-tagged text inside the element.

{\em Hierarchical Dropdown}

"Hierarchical dropdown" is a fancy way of saying "selecting one option sometimes brings up more specific options." You do this very simply, by including <opt> tags inside of other <opt> tags. For example:

<Script t="dropdown">

<desc>Type of used script.</desc>

<opts>

<opt>Archaic-Epichoric

<opt>A specific type of archaic-epichoric script

<opt>An even more specific type of that specific type archaic-epichoric script</opt>

</opt>

<opt>Another type of archaic-epichoric script</opt>

</opt>

<opt>Old-Attic</opt>

<opt>Ionic</opt>

<opt>Roman</opt>

<opt>Indistinguishable</opt>

<opt>Other</opt>

</opts>

</Script>

\subsubsubsection[using-the-translation-file]{Using the Translation File}

\subsubsubsection[autonumbering]{Autonumbering}

Basic autonumbering can be achieved using a combination of the f="autonum" flag and the <autonum/> tag. By flagging an input with "autonum", one indicates to the FAIMS-Tools that the ID of the next created entity---the entity containing the flagged field---should be taken from the corresponding field generated using the <autonum/> tag. For instance the Creatively_Named_ID in the below module will take its values from a field in Control which is generated by the use of the <autonum/> tag.

<module>

<Control>

<Control>

<Create_Entity t="button" l="Tab_Group" />

<autonum/>

</Control>

</Control>

<Tab_Group>

<Tab>

<Creatively_Named_ID f="id autonum" />

</Tab>

</Tab_Group>

</module>

The field will appear to the user as "Next Creatively Named ID" and will initially be populated with the number 1. When the user creates a Tab_Group entity, it will take that number as its "Creatively Named ID". The "Next Creatively Named ID" will then be incremented to 2, ready to be copied when a subsequent Tab_Group entity is created.

Multiple fields can be flagged as being autonumbered like so:

<module>

<Control>

<Control>

<Create_Entity t="button" l="Tab_Group" />

<autonum/>

</Control>

</Control>

<Tab_Group>

<Tab>

<Creatively_Named_ID f="id autonum" />

<Creatively_Named_ID_2 f="id autonum" />

</Tab>

</Tab_Group>

<Other_Tab_Group>

<Tab>

<Creatively_Named_ID_3 f="id autonum" />

</Tab>

</Other_Tab_Group>

</module>

\subsubsubsection[restricting-data-entry-to-decimals-for-a-field]{Restricting Data Entry to Decimals for a Field}

-Single flag to denote as a number field

\subsubsubsection[type-guessing-for-gui-elements-in-faims-tools]{Type Guessing for GUI Elements in FAIMS-Tools}

The FAIMS-Tools generate.sh program will attempt to make a reasonable assumption about what the t attribute should be set to if it is omitted from a GUI element's set of XML tags.

If the XML tags do not contain a set of <opts> tags nor the f="user" flag, t="input" is assumed. Example:

<Entity_Identifier f="id"/> <!-- This'll be an input -->

If the XML tag is flagged with f="user", t="dropdown" is assumed. Example:

<List_of_Users f="user"/> <!-- This'll be a dropdown -->

If the XML tags contain an <opts> element and no descendants with p attributes, t="list" is assumed. Example:

<Element> <!-- This'll be a list -->

<opts>

<opt>Option 1</opt>

<opt>Option 2</opt>

</opts>

</Element>

If the XML tags contain an <opts> element and one or more descendants with p attributes, t="picture" is assumed. Example:

<Element> <!-- This'll be a picture gallery -->

<opts>

<opt p="Lovely_Image.jpg>Option 1</opt>

<opt >Option 2</opt>

</opts>

</Element>

Finally, if the XML tags have the "ec" attribute, t="list" is assumed.

There are arguments both for and against the use of the type guessing feature because, while improving succinctness, it also makes the module.xml file less intelligible to uninitiated programmers. Because of this, the FAIMS-Tools will display warnings when a module is generated from an XML file whose GUI elements are missing their t attributes. These can be hidden by adding suppressWarnings="true" to the opening <module> tag like so:

<module suppressWarnings="true">

<!-- Tab groups go here... -->

</module>

\subsubsubsection[annotation-and-certainty]{Annotation and Certainty}

\subsubsubsection[exporting-data]{Exporting Data}

\subsubsection[advanced-faims-programming]{Advanced FAIMS Programming}

\subsubsubsection[module.xml-cheat-sheet]{module.xml Cheat Sheet}

For more information about the different XML attributes, flags, and relationship tags, we have a README file that you can access online here: \useURL[url24][https://github.com/FAIMS/FAIMS-Tools/blob/master/generators/christian/readme][][{\em https://github.com/FAIMS/FAIMS-Tools/blob/master/generators/christian/readme}]\from[url24] or in the generators/christian/ directory where you downloaded the FAIMS-Tools.

We'll repeat some of the information here for your reference. Be sure to open the README for the most up to date information: to learn how to include more advanced controls and scripting in your modules, look at the \useURL[url25][https://faimsproject.atlassian.net/wiki/display/FAIMS/FAIMS+Data\%2C+UI+and+Logic+Cook-Book][][{\em FAIMS Development Cookbook}]\from[url25], which includes code snippets for all of the things FAIMS can do.

ATTRIBUTES\crlf
\crlf
b Binding (See 'Bindings')\crlf
c Alias for faims_style_class\crlf
e="Type" Populates the menu with entities of the type `Type`. If the\crlf
`Type` is the empty string, entities of all types are shown.\crlf
ec, lc (See 'Child Entities')\crlf
f Flags (See 'Flags')\crlf
l Link to tab or tab group in the format Tabgroup/Tab/. Links\crlf
to tabs are discouraged as the generated code will contain\crlf
a race condition. Autogenerated code containing tab links\crlf
should be thoroughly tested.\crlf
p In <opt> tags, equivalent to pictureURL attribute.\crlf
suppressWarnings Prevents warnings from being shown when equal to "true" and\crlf
present in the <module> tag. Does not suppress errors.\crlf
t Type of GUI element (See 'Types'). If this attribute is\crlf
omitted from a view, t="input" is assumed.\crlf
________________________________________________________________________________\crlf
\crlf
BINDINGS\crlf
\crlf
- date\crlf
- decimal\crlf
- string\crlf
- time\crlf
Other bindings are possible (e.g. by writing b = "my-binding") but generate a\crlf
warning.\crlf
________________________________________________________________________________\crlf
\crlf
FLAGS\crlf
\crlf
hidden Equivalent to faims_hidden="true".\crlf
id Equivalent to isIdentifier="true".\crlf
noannotation Equivalent to faims_annotation="false".\crlf
nocertainty Equivalent to faims_certainty="false".\crlf
nolabel Prevents labels from being displayed or generated from element\crlf
names.\crlf
nosync Removes the faims_sync="true" attribute from audio, camera,\crlf
file and video GUI elements.\crlf
nothumb{[}nail{]} Removes the thumbnail="true" attribute from audio, camera,\crlf
file and video elements in the data schema.\crlf
noscroll Equivalent to faims_scrollable="false".\crlf
noui Only allows code related to the data schema to be generated.\crlf
nodata Generates code as usual, but ommits data schema entries.\crlf
readonly Equivalent to faims_read_only="true".\crlf
user Used to indicate that a menu should contain a list of users.\crlf
notnull Adds client- and server-side validation specifying that the\crlf
field should not be left blank.\crlf
________________________________________________________________________________\crlf
\crlf
TYPES\crlf
\crlf
Types of GUI element:\crlf
- audio <select type="file" faims_sync=true/>\crlf
<trigger/>\crlf
- button <trigger/>\crlf
- camera <select type="camera" faims_sync=true/>\crlf
<trigger/>\crlf
- checkbox <select/>\crlf
- dropdown <select1/>\crlf
- file <select type="file" faims_sync=true/>\crlf
<trigger/>\crlf
File list with a button to add a file\crlf
\crlf
- gpsdiag <input faims_read_only="true"/>...\crlf
- group <group/>\crlf
- input <input/>\crlf
- list <select1 appearance="compact"/>\crlf
- map <input faims_map="true"/>\crlf
- picture <select1 type="image"/>\crlf
- radio <select1 appearance="full"/>\crlf
- video <select type="file" faims_sync=true/>\crlf
<trigger/>\crlf
- viewfiles <trigger/>\crlf
A button to view all files related to an archent.\crlf
- web{[}view{]} <input faims_web="true"/>\crlf
________________________________________________________________________________\crlf
\crlf
RESERVED ELEMENT NAMES AND RECOMMENDED NAMING CONVENTIONS\crlf
\crlf
"Reserved" elements only contain lowercase letters:\crlf
- <col> One column in a <cols> tag\crlf
- <cols> Columns\crlf
- <desc> Description to put in the data schema\crlf
- <module>\crlf
- <opt> Option in <opts> tag\crlf
- <opts> Options for, say, a dropdown menu\crlf
- <rels> Intended to be a direct child of <module> and hold\crlf
<RelationshipElement> tags\crlf
- <gps> A set of fields including Latitude, Longitude, Northing,\crlf
Easting and a "Take From GPS" button.\crlf
- <search> A tab for searching all records. Its text is used as a label.\crlf
- <str> Contains <formatString>-related data.\crlf
- <pos> When the child of a <str>, gives the position (order) of an\crlf
identifier in a formatted string\crlf
- <fmt> When the child of a <str>, contains <formatString> data.\crlf
- <app> When the child of a <str>, contains <appendCharacterString>\crlf
data.\crlf
- <author> A read-only field displaying the username of the current user\crlf
or a message if the entity it appears in has not been saved.\crlf
- <timestamp> A read-only field displaying the creation time of the entity\crlf
it appears in.\crlf
User-defined elements should start with an uppercase letter and use\crlf
underscores as separators:\crlf
- <My_User_Defined_Element t="dropdown" />\crlf
Neither of these naming conventions are strictly enforced however.\crlf
________________________________________________________________________________\crlf
\crlf
INTENDED PURPOSE OF THE <rels> TAG\crlf
\crlf
When placed as a direct child of the <module> element, contents of the <rels>\crlf
tag are copied as-is to the generated data schema. No warnings are shown if\crlf
something is awry with its contents.\crlf
\crlf
Because the <rels> tags' contents are directly copied, in principle you could\crlf
put anything in there which you want to appear in the data schema. Doing so\crlf
would make you a bad person.\crlf
________________________________________________________________________________\crlf
\crlf
SEMANTICS OF <cols> TAGS\crlf
\crlf
Direct children of <cols> tags are interpreted as columns. For example,\crlf
<cols>\crlf
<Field_1 t="input"/>\crlf
<Field_2 t="input"/>\crlf
<Field_3 t="input"/>\crlf
</cols>\crlf
has three columns, each containing an input. The left-most column is Field_1,\crlf
whereas the right-most is Field_3.\crlf
\crlf
When a <col> tag is a direct child, its contents are interpreted as being part\crlf
of a distinct column. Therefore,\crlf
<cols>\crlf
<Field_1 t="input"/>\crlf
<col>\crlf
<Field_2 t="input"/>\crlf
<Field_3 t="input"/>\crlf
</col>\crlf
</cols>\crlf
results in two columns. The left column contains Field_1, while the right\crlf
contains Field_2 and Field_3.\crlf
________________________________________________________________________________\crlf
\crlf
CHILD ENTITIES\crlf
\crlf
Entities can be saved as children by the use of the "lc" attribute. For\crlf
instance, writing\crlf
<Add_Child t="button" lc="Child_Ent" />\crlf
generates a button which links to the Child_Ent tab group. When displayed by\crlf
clicking the Add_Child button, the Child_Ent tab group will have auto-saving\crlf
enabled and be saved as a child of the tab group that the button appeared in.\crlf
For example, consider the following module.xml:\crlf
<module>\crlf
<Tab_Group>\crlf
<Tab>\crlf
<Add_Child t="button" lc="Tab_Group" />\crlf
</Tab>\crlf
</Tab_Group>\crlf
</module>\crlf
Clicking the Add_Child button will cause the user to be taken to a new\crlf
instance of Tab_Group which will be saved as a child of the original instance.\crlf
But because the original instance was not loaded by clicking the button, it\crlf
will not be saved as a child.\crlf
\crlf
A list of child entities can be displayed to the user by using the "ec"\crlf
attribute:\crlf
<List_Of_Related_Entities t="list" ec="Type_Of_Childen" />\crlf
The list will be populated with entities which are children of the tab group\crlf
the list appears in. The entities will be constrained to have the type\crlf
"Type_Of_Children". However, writing `ec=""` produces an unconstrained list,\crlf
where children of all types are displayed.\crlf
\crlf
The user should note carefully that, while including an "lc" attribute causes\crlf
a corresponding <RelationshipElement> to be generated in the data schema,\crlf
including an "ec" attribute does not.\crlf
________________________________________________________________________________\crlf
\crlf
LABELS\crlf
\crlf
An element's text is taken as its label. For instance, the following input\crlf
<My_Input t="input">\crlf
Droopy Soup\crlf
<desc>Similar to drippy soup, but not quite...</desc>\crlf
</My_Input>\crlf
has the label "Droopy Soup". Note that following and preceding whitespace is\crlf
stripped.\crlf
\crlf
If a label is not provided, it is "inferred" from the element's name. More\crlf
specifically, underscores in the element's name are replaced with spaces,\crlf
which becomes the element's label. Therefore, the element\crlf
<Droopy_Soup t="input">\crlf
<desc>Similar to drippy soup, but not quite...</desc>\crlf
</Droopy_Soup>\crlf
has the same label as in the above example. Thus, the user will see exactly\crlf
the same thing in both cases. However, their representations in the data and\crlf
UI schemas, and the arch16n file will be different.\crlf
\crlf
You are recommended to use this "inference" feature, as it encourages\crlf
consistency between the label, which the user sees, and the view's reference\crlf
and faims_attribute_name, which the programmer sees. Note that it merely\crlf
"encourages" consistency as the programmer can change the corresponding,\crlf
generated, arch16n (english.0.properties) entry.\crlf
________________________________________________________________________________\crlf
\crlf
GENERATION OF THE ARCH16N FILE\crlf
\crlf
Labels and menu options (e.g. from checkboxes and dropdowns) have arch16n\crlf
entries generated for them. The left-hand side of an arch16n entry (i.e.\crlf
everything to the left of the equals sign) is produced by changing all\crlf
non-alphanumeric characters in the label or menu option to underscores. The\crlf
right-hand side is the unmodified text.\crlf
\crlf
The created arch16n entries are used in the generated UI and data schemas.\crlf
\crlf
It should be carefully noted that replacing characters as described above can\crlf
cause naming conflicts. For example, if the module.xml file contains the\crlf
labels "I'm cool!" and "I'm cool?", the generated arch16n file will contain\crlf
the following lines:\crlf
I_m_cool_=I'm cool!\crlf
I_m_cool_=I'm cool?\crlf
Moreover, the programmer is not warned if such a conflict exists, as, in\crlf
practise, it assumed that such conflicts are very rare and checking for them\crlf
in XSLT 1.0 violates Article 5 of 'The Universal Declaration of Human Rights'.

\section[section-6]{\crlf
}
\stoptext
\stopcomponent

\stoptext
\stopcomponent
